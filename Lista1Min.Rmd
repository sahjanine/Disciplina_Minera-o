---
title: "Lista 1 - Mineração de Dados"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE,}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, results = "hide",message = FALSE,warning=FALSE}
#carregando pacotes
library(dplyr)
library(readr)
library(tidyr)
library(glmnet)
library(ggplot2)
library(gridExtra)

```


```{r}
#lendo os dados
dados_1 <- read_csv("C:/Users/011694631/Downloads/houses_to_rent_v2.csv")

#selecionando as cidades de interesse
dados=dados_1 %>%  filter(city %in% c("São Paulo", "Rio de Janeiro","Belo Horizonte"))

#verificando NA
sum(!complete.cases(dados)) #não tem NA

#trocando nome das variáveis
colnames(dados)=c("cidade","area","quartos","banheiros","vagas","piso","animal","mobiliado","aluguel")

tipo_imovel=numeric(nrow(dados)) # criando variável tipo de imóvel
for(i in 1:nrow(dados)){
  tipo_imovel[i]=ifelse(dados$piso[i]=="-","casa","apartamento")
  }

#juntando a variável na base "dados"
dados=cbind(dados,tipo_imovel)

#limpeza da variável chão (troca "-" por 1 temporariamente)
for(i in 1:nrow(dados)){
  dados$piso[i]=ifelse(dados$piso[i]=="-",1,dados$piso[i])
}

#faz agrupamento da variável chao (original tem muitas categorias)
agrupamento_chao=numeric(nrow(dados))
agrupamento_chao=cut(as.numeric(dados$piso),
                             breaks=c(0,5,10,15,20,Inf),
                             labels=c("1","2","3","4","5"))

#substitui na base
dados$piso=as.numeric(agrupamento_chao)

#onde o tipo de imóvel é "casa", chão é zero
for(i in 1:nrow(dados)){
  dados$piso[i]=ifelse(dados$tipo_imovel[i]=="casa",0,dados$piso[i])
}

sapply(dados, class) #verificando as classes das variáveis

dados$quartos=factor(dados$quartos)
dados$banheiros=factor(dados$banheiros)
dados$cidade=factor(dados$cidade)
dados$vagas=factor(dados$vagas)
dados$piso=factor(dados$piso)
dados$animal=factor(dados$animal)
dados$mobiliado=factor(dados$mobiliado)
dados$tipo_imovel=factor(dados$tipo_imovel)


head(dados)
```
Inicialmente, avaliamos a distribuição da variável resposta valor do aluguel.
```{r, echo=FALSE}

aluguel<-ggplot(dados, aes(x=aluguel)) + 
  geom_histogram( fill="#69b3a2", color="#e9ecef", alpha=0.9)+ 
  theme_classic()+
  labs(y = "Frequência", x = "Variável resposta Valor do aluguel",
       title = "Distribuição do aluguel")+
  theme( plot.title = element_text(hjust = 0.4, size = 10),
         axis.title = element_text(size = 9),
         axis.text = element_text(size = 7), 
         title =  element_text(size = 4))

log_aluguel<-ggplot(dados, aes(x=log(aluguel))) + 
  geom_histogram( fill="#69b3a2", color="#e9ecef", alpha=0.9)+ 
  theme_classic()+
  labs(y = "Frequência", x = "Variável resposta Valor do aluguel",
       title = "Distribuição do log(aluguel)")+
  theme( plot.title = element_text(hjust = 0.4, size = 10),
         axis.title = element_text(size = 9),
         axis.text = element_text(size = 9), 
         title =  element_text(size = 4))

grid.arrange(aluguel,log_aluguel,nrow=1)

```
Observa-se um comportamento assimétrico à direita para a distribuição dos valores da variável resposta. Tal comportamento pode impactar na estimativa dos parâmetros e sua respectiva escala ao ajustar os modelos. Dessa forma, optamos por utilizar o logaritmo da variável resposta.
```{r cars}
#dividindo a amostra em treino e teste
set.seed(26) #semente para manter a amostra fixa
row.number = sample(1:nrow(dados), 0.85*nrow(dados)) #sorteando as linhas
treino = dados[row.number,] #amostra treino
teste=dados[-row.number,] #amostra teste
```

A divisão da base original é feita de modo que tenhamos uma base de treino e uma base de teste. No ajuste do modelo utilizamos a base de treino para que os parâmetros sejam estimados. Posteriormente é necessário verificar se esse modelo performa bem, ou seja, se o mesmo faz boas previsões e tem um risco baixo. Essa verificação da precisão do modelo não deve ser feita na base na qual o modelo foi ajustado, uma vez que isso traz um viés nas conclusões. Dessa forma a verificação é feita na base de teste.

A questão é como separar a base original para que essas etapas seja concluídas com sucesso. No nosso caso, a base original tem 8646 observações, um tamanho relativamente grande pensando que temos poucas covariáveis e consequentemente poucos parâmetros para serem estimados. Como a base de teste é utilizada para estimar o risco, que nada mais é que uma média, nesse trabalho consideramos 15% (1297 linhas) da base original um tamanho adequado para testar o modelo (formar a base de teste). Com isso as 7349 observações restante serão reservadas para o ajuste do modelo, ou seja, formaram a base de treino.


```{r}
ytreino=log(treino$aluguel)
xtreino=model.matrix(~.,treino[,-9])

#ajuste por mínimos quadrados 
ajuste_mq=glmnet(xtreino,ytreino,lambda=0)

#validação cruzada do lasso (escolha do lambda mínimo)
vc_lasso=cv.glmnet(xtreino,ytreino,alpha=1)
vc_lasso

#ajuste do lasso considerando o lambda mínimo da VC
ajuste_lasso=glmnet(xtreino,ytreino,alpha=1,lambda=vc_lasso$lambda.min)

```

```{r}
#Transformando as variaveis preditoras em uma matriz
xteste <- model.matrix(~.,teste[,-9])

#Pegando a variavel resposta
yteste <- log(teste$aluguel)

#Predição do minimos quadrados
predito_mq <- predict(ajuste_mq, newx = xteste)

#EQM do minimos quadrados
eqm_mq <- mean((yteste - predito_mq)^2)

#Predição do lasso
predito_lasso <- predict(ajuste_lasso,
                         s = vc_lasso$lambda.min, newx = xteste)

#EQM do lasso
eqm_lasso <- mean((yteste - predito_lasso)^2)
```


A partir da regressão ajustada para os dois métodos, observa-se que o Risco preditivo pelo método de mínimos quadrados é um pouco inferior em relação ao método lasso, conforme é possível ver na tabela a seguir:

```{r}
riscos<- data.frame(eqm_mq,eqm_lasso)
row.names(riscos)<-"Risco preditivo"
colnames(riscos)<-c("Mínimos quadrados","Lasso")
riscos %>% knitr::kable(align = "c")
```

Ainda, para o método Lasso, temos que o valor de $\lambda$ que minimiza o Erro Quadrático médio é dado por
```{r }
vc_lasso$lambda.min
```


Além disso, considerando a expressão dada para obter o intervalo de confiança para o risco $\hat{R}(g)\pm2 \sqrt{\frac{1}{m}\hat{\sigma}^{2}}$ tal que $\hat{\sigma}^{2}=\frac{1}{m}\sum_{i=1}^{m}(W_{k}-\bar{W})^{2}$,
temos os intervalos de confiança aproximados de 95$\%$ obtidos para os dois métodos:

##Mínimos Quadrados

```{r}
#risco estimado 
m<-length(eqm_mq)
W_mmq<-(predito_mq - yteste)^2
sigma2_mq<- (W_mmq- mean(W_mmq))^2%>%mean()
#Intervalo de confiança
ic_risco_mq<- c(eqm_mq-2*(sqrt(sigma2_mq/m)),eqm_mq+2*(sqrt(sigma2_mq/m)))
ic_risco_mq
```

Assim, para o método de mínimos quadrados considerando uma aproximação de 4 casas decimais
$$IC(R(g),95\%)=(-0.5695,1.0690)$$
E a amplitude do intervalo é de aproximadamente $1.0690 + 0.5695=1.6385$.

##Lasso

```{r }
#risco estimado

W_lasso<-(predito_lasso - yteste)^2
m<-length(eqm_lasso)
sigma2<- (W_lasso- mean(W_lasso))^2%>%mean()
#Intervalo de confiança
ic_risco_lasso<- c(eqm_lasso-2*(sqrt(sigma2/m)),eqm_lasso+2*(sqrt(sigma2/m)))
ic_risco_lasso
```
Assim, para o método do lasso considerando uma aproximação de 4 casas decimais
$$IC(R(g),95\%)=(-0.5699,1.0696)$$
E a amplitude do intervalo é de aproximadamente $1.0696 + 0.5699=1.6395$.

Logo, com confiança de aproximadamente 95 % temos que o intervalo para o risco pelo método de mínimos quadrados possui uma amplitude um pouco menor em relação ao método lasso, fornecendo indícios do primeiro ser um estimador melhor em relação ao segundo.

Dessa forma, considerando o modelo de mínimos quadrados temos que o vetor de coeficientes estimado é dado por:
```{r }
beta<- round(ajuste_mq$beta, digits = 6)
beta
```
Podemos observar que o coeficiente associado à cidade de São Paulo apresenta um valor um pouco maior, o que implica que para esta cidade o logaritmo do valor de aluguel será maior. A representação gráfica para os valores de aluguel por cidade são apresentados no gráfico boxplot a seguir.


```{r, echo=FALSE}

ggplot(dados, aes(y = log(aluguel), x = cidade, fill = cidade)) +
  geom_boxplot(show.legend = F, alpha = .7) +
  theme_classic(base_size = 15) +
  labs(y = "log(Valor do aluguel)", x = "Cidade",
       title = "Boxplot do Valor do aluguel por Cidade")+
  theme( plot.title = element_text(hjust = 0.4),
         axis.title = element_text(size = 11),
         axis.text = element_text(size = 13), 
         title =  element_text(size = 10) ) 


```


Podemos observar que de fato a mediana do logaritmo do valor de aluguel da cidade de São Paulo é superior em relação às demais. Ainda, destaca-se que para a cidade de Belo Horizonte há uma maior variabilidade, sendo que o valor mediano do logaritmo do alguel é muito próximo entre esta cidade com o Rio de Janeiro. Vale ressaltar que o fato da cidade de São Paulo apresentar um valor de aluguel superior em relação às demais faz sentido uma vez que a mesma é mais populosa e representa um grande centro urbano, o que implica em custos maiores.

Na sequência podemos observar que o coeficiente associado à variável área é muito pequeno, com pouca contribuição no valor do aluguel. Neste caso, não condiz com o esperado uma vez que imagina-se que quanto maior for o tamanho da residência, maior será o valor do aluguel. 

Para a variável número de quartos, observa-se que quanto maior a quantidade de cômodos, maiores são os coeficientes associados, contribuindo para um maior valor no logaritmo do aluguel. Contudo, destaca-se que para imóveis com 9 ou 10 quartos há um decaimento no valor do coeficiente associado, fato que podemos questionar o motivo de tal comportamento. Para melhor investigar, observa-se o gráfico boxplot a seguir:

```{r, echo=FALSE}

ggplot(dados, aes(y = log(aluguel), x = quartos, fill=quartos)) +
  geom_boxplot(show.legend = F, alpha = .7) +
  theme_classic(base_size = 15) +
  labs(y = "log(Valor do aluguel)", x = "Número de quartos",
       title = "Boxplot do Valor do aluguel por Número de quartos")+
  theme( plot.title = element_text(hjust = 0.4),
         axis.title = element_text(size = 11),
         axis.text = element_text(size = 13), 
         title =  element_text(size = 10) ) 


```


Nota-se que o valor do coeficiente associado ao número de quartos igual a 8 pode ser um pouco superior em relação à 9 quartos devido a presença de um valor outlier
nesta categoria. Por outro lado, observa-se que de fato a mediana do valor do logaritmo do aluguel para 10 quartos é inferior em relação à 9 quartos.
Assim, de forma geral, é possível afirmar que há uma coerência nos valores dos coeficientes estimados para esta variável.

Com relação ao número de banheiros, observa-se um comportamento semelhante ao número de quartos, isto é, os coeficientes aumentam conforme há uma maior quantidade deste cômodo, com uma leve queda para 9 banheiros e um número relativamente menor para 10. Como complemento, temos o gráfico boxplot:

```{r, echo=FALSE}

ggplot(dados, aes(y = log(aluguel), x = banheiros, fill=banheiros)) +
  geom_boxplot(show.legend = F, alpha = .7) +
  theme_classic(base_size = 15) +
  labs(y = "log(Valor do aluguel)", x = "Número de banheiros",
       title = "Boxplot do Valor do aluguel por Número de banheiros")+
  theme( plot.title = element_text(hjust = 0.4),
         axis.title = element_text(size = 11),
         axis.text = element_text(size = 13), 
         title =  element_text(size = 10) ) 


```


Neste caso, a mediana do logaritmo do aluguel para imóveis com 9 banheiros demonstra ser menor em relação à 8, enquanto que para 10 banheiros a mediana é superior em relação à 9 e muito próxima de 8 banheiros. Portanto, temos que com exceção do caso para 10 banheiros, os coeficientes, parecem estar coerentes.

Para a variável vagas que representa o número de vagas de estacionamento temos que quanto maior o número de vagas, maior o coeficiente associado à categoria, isto é, maior o valor esperado do logaritmo do aluguel. Contudo, observa-se uma exceção para o caso extremo do número de vagas igual a 12, em que há uma queda no valor do coeficiente. O gráfico boxplot dessa variável é apresentado a seguir:
```{r , echo=FALSE}

ggplot(dados, aes(y = log(aluguel), x = vagas, fill=vagas)) +
  geom_boxplot(show.legend = F, alpha = .7) +
  theme_classic(base_size = 15) +
  labs(y = "log(Valor do aluguel)", x = "Número de vagas",
       title = "Boxplot do Valor do aluguel por Número de vagas")+
  theme( plot.title = element_text(hjust = 0.4),
         axis.title = element_text(size = 11),
         axis.text = element_text(size = 13), 
         title =  element_text(size = 10) ) 


```


Nota-se que a mediana do logaritmo do aluguel para 10 e 12 vagas estão muito próximas, sendo que para 12 vagas, há uma variabilidade muito pequena no valor do aluguel, fato que pode justificar a diferença para o coeficiente associado a esta categoria.

Em seguida, para a variável piso, a qual representa o número de andares do imóvel é possível identificar de forma geral um aumento nos coeficientes conforme aumenta a categoria da quantidade de andares. Podemos observar o gráfico boxplot a seguir:
```{r, echo=FALSE}

ggplot(dados, aes(y = log(aluguel), x = piso, fill=piso)) +
  geom_boxplot(show.legend = F, alpha = .7) +
  theme_classic(base_size = 15) +
  labs(y = "log(Valor do aluguel)", x = "Número de andares",
       title = "Boxplot do Valor do aluguel por Número de andares")+
  theme( plot.title = element_text(hjust = 0.4),
         axis.title = element_text(size = 11),
         axis.text = element_text(size = 13), 
         title =  element_text(size = 10) ) 

```


É possível identificar que o valor da mediana do logaritmo do aluguel parece estar próximo entre as categorias de número de andares, sendo para a categoria 1, a qual representa andares de 1 a 5 é a que possui menor valor de aluguel. Uma possível associação a este fato é a de que apartamentos com andares mais inferiores costumam ter um valor de aluguel menor em relação à andares superiores.

Para a variável animal, temos pelo valor do coeficiente estimado que esta não parece contribuir para o valor do logaritmo do aluguel, com coeficiente muito próximo de zero. Tal fato é razoável uma vez que a presença de animais pode ser relativa com relação ao valor do aluguel, isto é, espera-se que com a presença de animais há um maior possibilidade de degradação dos ambientes devido ao possível comportamento dos animais, o que requer reparos no imóvel. Contudo, não é possível generalizar essa afirmativa, o que implica a pouca contribuição dessa variável.

No caso da variável mobiliado, é possível observar que para imóveis que não são mobiliados o valor esperado do logaritmo do aluguel é menor, fato que é razoável uma vez que ao se alugar um imóvel com mobílias, é incluída uma taxa de aluguel sobre os móveis a serem utilizados.

Por fim, temos que para a variável criada tipo de imóvel, o coeficiente é muito próximo de zero, fornecendo indícios de que o tipo de imóvel não influencia no valor do logaritmo do aluguel, o que pode ser justificado por diferentes razões como, por exemplo, podem haver apartamentos luxuosos com valor de aluguel maior em relação à casas mais simples.

Considerando as interações 2 a 2 das variáveis preditoras.
```{r}
xtreino_2=model.matrix(~(.)^2,treino[,-9])
Xtes_2=model.matrix(~(.)^2,teste[,-9])
Y<- log(treino$aluguel)
####LASSO
cv_lasso2<- cv.glmnet(xtreino_2,Y,alpha = 1)

plot(cv_lasso2)
#minimos quadrados
ajuste_mq2 <- glmnet(xtreino_2, Y,alpha = 0, lambda = 0)
predito_mmq2 <- predict(ajuste_mq2, newx = Xtes_2)


ajuste_lasso2<-glmnet(xtreino_2,Y,alpha = 1, lambda =cv_lasso2$lambda.min )

predito_lasso2<- predict(ajuste_lasso2, s=cv_lasso2$lambda.min,newx= Xtes_2)


#risco estimado 
risco_mq2<- (predito_mmq2 - yteste)^2%>%mean()
risco_mq2
m<-length(risco_mq2)
W_mmq2<-(predito_mmq2 - yteste)^2
sigma2_mq2<- (W_mmq2- mean(W_mmq2))^2%>%mean()

ic_risco_mq2<- c(risco_mq2-2*(sqrt(sigma2_mq2/m)),risco_mq2+2*(sqrt(sigma2_mq2/m)))
ic_risco_mq2



risco_lasso2<- (predito_lasso2 - yteste)^2%>%mean() 
risco_lasso2
W_lasso2<-(predito_lasso2 - yteste)^2
m<-length(risco_lasso2)
sigma2_int<- (W_lasso2- mean(W_lasso2))^2%>%mean()
ic_risco_lasso2<- c(risco_lasso2-2*(sqrt(sigma2_int/m)),risco_lasso2+2*(sqrt(sigma2_int/m)))

ic_risco_lasso2
```
